<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>BrutalSpan</title>
    <style>
        :root {
            --bg: #050505;
            --surf: #111;
            --brd: #222;
            --txt: #fff;
            --dim: #666;
            --neon-green: #39ff14;
            --neon-red: #ff3131;
            --neon-blue: #00f3ff;
        }

        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            outline: none;
        }

        body {
            background: var(--bg);
            color: var(--txt);
            font-family: 'Inter', sans-serif;
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
        }

        /* --- DYNAMIC BACKGROUND & EFFECTS --- */
        body::before {
            content: "";
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, #111 0%, #000 100%);
            z-index: -1;
        }

        .scanlines {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.1) 50%);
            background-size: 100% 4px;
            z-index: 100;
            pointer-events: none;
        }

        #app {
            width: 100%;
            max-width: 380px;
            padding: 30px;
            z-index: 10;
            text-align: center;
        }

        /* --- GAME UI --- */
        .lvl-header {
            font-size: 10px;
            letter-spacing: 4px;
            color: var(--neon-blue);
            margin-bottom: 20px;
            text-transform: uppercase;
            text-shadow: 0 0 5px var(--neon-blue);
        }

        #timer-container {
            width: 100%;
            height: 3px;
            background: #111;
            margin-bottom: 40px;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: inset 0 0 5px #000;
        }

        #timer-bar {
            width: 100%;
            height: 100%;
            background: var(--neon-blue);
            box-shadow: 0 0 10px var(--neon-blue);
            transform-origin: left;
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
        }

        .tile {
            aspect-ratio: 1;
            background: var(--surf);
            border: 2px solid var(--brd);
            border-radius: 12px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 28px;
            font-weight: 700;
            cursor: pointer;
            transition: 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            color: var(--txt);
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }

        .tile:active {
            transform: scale(0.92);
            background: #1a1a1a;
        }

        .tile.hidden-num {
            color: transparent;
            text-shadow: none;
            border-color: #1a1a1a;
        }

        .tile.correct {
            border-color: var(--neon-green);
            color: var(--neon-green);
            box-shadow: 0 0 20px var(--neon-green), 0 0 40px rgba(57, 255, 20, 0.4);
            background: rgba(57, 255, 20, 0.1);
            animation: correctPulse 0.3s ease-out;
        }

        @keyframes correctPulse {
            0% {
                transform: scale(1);
                box-shadow: 0 0 20px var(--neon-green);
            }

            50% {
                transform: scale(1.05);
                box-shadow: 0 0 40px var(--neon-green), 0 0 60px rgba(57, 255, 20, 0.6);
            }

            100% {
                transform: scale(1);
                box-shadow: 0 0 20px var(--neon-green);
            }
        }

        /* --- SCREENS --- */
        .roast-box {
            min-height: 200px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            padding: 0 10px;
        }

        .roast-text {
            font-size: 18px;
            line-height: 1.5;
            color: #ccc;
            opacity: 0;
            transition: 0.5s;
            font-weight: 500;
        }

        .roast-text.visible {
            opacity: 1;
        }

        .meme-frame {
            width: 280px;
            height: 280px;
            margin: 20px auto 0;
            border-radius: 12px;
            background-size: cover;
            background-position: center;
            filter: grayscale(0);
            opacity: 0;
            transition: opacity 0.8s, filter 0.8s;
            border: 2px solid var(--neon-blue);
            display: none;
            box-shadow: 0 0 20px rgba(0, 243, 255, 0.3);
        }

        button.glow-btn {
            background: transparent;
            border: 2px solid var(--neon-blue);
            color: var(--neon-blue);
            padding: 15px;
            width: 100%;
            border-radius: 8px;
            font-weight: 700;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-top: 30px;
            box-shadow: 0 0 10px rgba(0, 243, 255, 0.2);
            transition: 0.3s;
        }

        button.glow-btn:hover {
            background: var(--neon-blue);
            color: #000;
            box-shadow: 0 0 20px var(--neon-blue);
        }

        .hidden {
            display: none !important;
        }

        /* Setup visuals */
        .opt-label {
            font-size: 10px;
            color: var(--dim);
            margin: 20px 0 10px;
            text-transform: uppercase;
            text-align: left;
            display: block;
        }

        .seg-ctrl {
            display: flex;
            gap: 5px;
            margin-bottom: 20px;
        }

        .seg {
            flex: 1;
            padding: 12px;
            background: #111;
            border: 1px solid #222;
            border-radius: 6px;
            font-size: 12px;
            cursor: pointer;
            color: #444;
        }

        .seg.active {
            border-color: var(--neon-blue);
            color: var(--neon-blue);
            background: rgba(0, 243, 255, 0.05);
        }

        /* Video container styling */
        .video-container {
            width: 100%;
            max-width: 350px;
            margin: 20px auto;
            border-radius: 12px;
            overflow: hidden;
            border: 2px solid var(--neon-blue);
            box-shadow: 0 0 20px rgba(0, 243, 255, 0.3);
        }

        .video-container video {
            width: 100%;
            height: auto;
            display: block;
        }

        .challenge-text {
            text-align: center;
            font-size: 16px;
            color: var(--neon-green);
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-top: 15px;
            font-weight: 700;
            text-shadow: 0 0 10px var(--neon-green);
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.7;
            }
        }

        /* Lifeline hearts */
        .hearts-container {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 15px;
        }

        .heart {
            width: 24px;
            height: 24px;
            position: relative;
            animation: heartbeat 1.5s ease-in-out infinite;
        }

        .heart::before,
        .heart::after {
            content: "";
            position: absolute;
            top: 0;
            width: 13px;
            height: 20px;
            border-radius: 13px 13px 0 0;
            background: var(--neon-red);
            box-shadow: 0 0 10px var(--neon-red);
        }

        .heart::before {
            left: 13px;
            transform: rotate(-45deg);
            transform-origin: 0 100%;
        }

        .heart::after {
            left: 0;
            transform: rotate(45deg);
            transform-origin: 100% 100%;
        }

        .heart.lost::before,
        .heart.lost::after {
            background: #333;
            box-shadow: none;
        }

        @keyframes heartbeat {

            0%,
            100% {
                transform: scale(1);
            }

            10% {
                transform: scale(1.1);
            }

            20% {
                transform: scale(1);
            }
        }

        /* Checkpoint indicator */
        .checkpoint-info {
            font-size: 9px;
            color: var(--dim);
            text-align: center;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .checkpoint-info .cp-label {
            color: var(--neon-blue);
            text-shadow: 0 0 5px var(--neon-blue);
        }

        /* Mute button */
        .mute-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 45px;
            height: 45px;
            background: rgba(17, 17, 17, 0.8);
            border: 2px solid var(--brd);
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            transition: 0.3s;
            z-index: 1000;
        }

        .mute-btn:hover {
            border-color: var(--neon-blue);
            box-shadow: 0 0 15px rgba(0, 243, 255, 0.3);
        }

        .mute-btn.muted {
            border-color: var(--neon-red);
            box-shadow: 0 0 15px rgba(255, 49, 49, 0.3);
        }
    </style>
</head>

<body>
    <div class="scanlines"></div>

    <!-- Mute button -->
    <div class="mute-btn" id="muteBtn" onclick="toggleMute()" title="Toggle Mute">
        <span id="muteIcon">ðŸ”Š</span>
    </div>

    <!-- Audio elements -->
    <audio id="bgMusic" loop>
        <source src="assets/audio/background-music.mp3" type="audio/mpeg">
    </audio>

    <div id="app">
        <div id="setup">
            <h1 style="letter-spacing: 8px; font-weight: 900; color: var(--txt);">BrutalSpan</h1>
            <p
                style="text-align: center; color: var(--neon-green); font-size: 14px; letter-spacing: 3px; margin-top: -10px; margin-bottom: 20px; text-transform: uppercase; font-weight: 600; text-shadow: 0 0 10px var(--neon-green);">
                Fix your Memory</p>

            <!-- Video Section -->
            <div class="video-container">
                <video id="introVideo" autoplay muted playsinline>
                    <source src="assets/video/intro-video.mp4" type="video/mp4">
                </video>
            </div>
            <div class="challenge-text">Can you beat this guy?</div>

            <span class="opt-label">Judgment Intensity</span>
            <div class="seg-ctrl">
                <div class="seg" onclick="playClick(); setOpt('lvl', 1)">Gentle</div>
                <div class="seg active" onclick="playClick(); setOpt('lvl', 2)">Honest</div>
                <div class="seg" onclick="playClick(); setOpt('lvl', 3)">Brutal</div>
            </div>
            <span class="opt-label">Language</span>
            <div class="seg-ctrl">
                <div class="seg active" onclick="playClick(); setOpt('lang', 'en')">English</div>
                <div class="seg" onclick="playClick(); setOpt('lang', 'hi')">Hinglish</div>
            </div>
            <button class="glow-btn" onclick="playClick(); start()">Initialize</button>
        </div>

        <div id="game" class="hidden">
            <div class="checkpoint-info" id="checkpoint-info">Checkpoint 1 <span class="cp-label">[0/5 Grids]</span>
            </div>
            <div class="hearts-container" id="hearts">
                <div class="heart"></div>
                <div class="heart"></div>
                <div class="heart"></div>
                <div class="heart"></div>
                <div class="heart"></div>
            </div>
            <div class="lvl-header" id="lvl-tag">Level // 01</div>
            <div style="font-size: 11px; color: var(--neon-blue); text-align: center; margin-bottom: 15px; letter-spacing: 2px;"
                id="grid-counter">Grids Solved: 0</div>
            <div id="timer-container">
                <div id="timer-bar"></div>
            </div>
            <div class="grid" id="grid"></div>
        </div>

        <div id="fail" class="hidden">
            <div class="roast-box">
                <div id="roast-msg" class="roast-text"></div>
                <div id="meme" class="meme-frame"></div>
            </div>
            <div id="stats" style="font-size: 12px; color: var(--dim); margin-top: 20px;"></div>
            <button class="glow-btn" onclick="playClick(); retryGame()">Re-Try</button>
        </div>
    </div>

    <script>
        // Dynamic roast data - will be loaded from Roast.md
        let ROASTS = {
            english: [],
            hinglish: [],
            memes: []
        };

        let cfg = { lvl: 2, lang: 'en', streak: 0 };
        let g = {
            cur: 1,
            exp: 1,
            data: [],
            state: 'IDLE',
            timer: null,
            usedRoasts: new Set(),
            usedMemes: new Set(),
            lives: 5,
            checkpoint: 1,
            checkpointLevel: 1,
            gridsSolved: 0,
            gridsAtCheckpoint: 0
        };

        // Audio setup
        const bgMusic = document.getElementById('bgMusic');
        bgMusic.volume = 0.10; // Soft 10% volume
        let isMuted = false;

        // Web Audio API for click sound
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();

        function playClick() {
            // Resume audio context if needed (for browsers requiring user interaction)
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }

            // Vibrate on mobile (subtle 20ms)
            if (navigator.vibrate) {
                navigator.vibrate(20);
            }

            // Only play sound if not muted
            if (!isMuted) {
                // Create a simple click sound using Web Audio API
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                oscillator.frequency.value = 800;
                oscillator.type = 'sine';

                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);

                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.1);
            }
        }

        function playTileClick() {
            // Resume audio context if needed
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }

            // Vibrate on mobile (subtle 15ms for tiles)
            if (navigator.vibrate) {
                navigator.vibrate(15);
            }

            // Only play sound if not muted
            if (!isMuted) {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                oscillator.frequency.value = 600;
                oscillator.type = 'sine';

                gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.08);

                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.08);
            }
        }

        function toggleMute() {
            isMuted = !isMuted;
            const muteBtn = document.getElementById('muteBtn');
            const muteIcon = document.getElementById('muteIcon');

            if (isMuted) {
                bgMusic.muted = true;
                muteBtn.classList.add('muted');
                muteIcon.textContent = 'ðŸ”‡';
            } else {
                bgMusic.muted = false;
                muteBtn.classList.remove('muted');
                muteIcon.textContent = 'ðŸ”Š';
            }
        }

        // Parse Roast.md file
        async function loadRoasts() {
            try {
                const response = await fetch('src/data/Roast.md');
                const text = await response.text();
                const lines = text.split('\n');

                let currentSection = null;
                let inMemesSection = false;

                for (let line of lines) {
                    const trimmed = line.trim();

                    // Detect section headers
                    if (trimmed.toLowerCase().includes('english roast')) {
                        currentSection = 'english';
                        inMemesSection = false;
                        continue;
                    }

                    if (trimmed.toLowerCase().includes('hinglish roast')) {
                        currentSection = 'hinglish';
                        inMemesSection = false;
                        continue;
                    }

                    if (trimmed.toLowerCase().includes('memes link')) {
                        inMemesSection = true;
                        currentSection = null;
                        continue;
                    }

                    // Extract roast lines
                    if (currentSection && trimmed.length > 0) {
                        if (!trimmed.startsWith('#') &&
                            !trimmed.startsWith('---') &&
                            !trimmed.startsWith('##') &&
                            trimmed.length > 10) {
                            ROASTS[currentSection].push(trimmed);
                        }
                    }

                    // Extract meme URLs
                    if (inMemesSection && trimmed.startsWith('http')) {
                        ROASTS.memes.push(trimmed);
                    }
                }

                console.log(`âœ“ Loaded ${ROASTS.english.length} English roasts`);
                console.log(`âœ“ Loaded ${ROASTS.hinglish.length} Hinglish roasts`);
                console.log(`âœ“ Loaded ${ROASTS.memes.length} memes`);
            } catch (error) {
                console.error('Failed to load roasts:', error);
                // Fallback roasts
                ROASTS.english = ["Your memory needs a serious upgrade."];
                ROASTS.hinglish = ["Yaadaasht kamzor hai bhai."];
                ROASTS.memes = ["https://media.giphy.com/media/9Y5BbDSkSTiY8/giphy.gif"];
            }
        }

        // Load roasts when page loads
        loadRoasts();

        // Stop intro video after 10 seconds
        const introVideo = document.getElementById('introVideo');
        if (introVideo) {
            introVideo.addEventListener('loadedmetadata', function () {
                setTimeout(() => {
                    introVideo.pause();
                }, 10000); // 10 seconds
            });
        }

        function setOpt(k, v) {
            cfg[k === 'lvl' ? 'lvl' : 'lang'] = v;
            const parent = k === 'lvl' ? document.querySelectorAll('.seg-ctrl')[0] : document.querySelectorAll('.seg-ctrl')[1];
            parent.querySelectorAll('.seg').forEach((s, i) => s.classList.toggle('active', (k === 'lvl' ? i + 1 === v : (v === 'en' ? i === 0 : i === 1))));
        }

        function start() {
            g.exp = 1; g.state = 'REVEAL';

            // Reset lives only if starting fresh from level 1
            if (g.cur === 1 && g.gridsSolved === 0) {
                g.lives = 5;
                g.checkpoint = 1;
                g.checkpointLevel = 1;
                g.gridsSolved = 0;
                g.gridsAtCheckpoint = 0;
            }

            document.getElementById('setup').classList.add('hidden');
            document.getElementById('fail').classList.add('hidden');
            document.getElementById('game').classList.remove('hidden');

            // Start background music
            if (bgMusic.paused) {
                bgMusic.play().catch(e => console.log('Audio play failed:', e));
            }

            updateHearts();
            updateCheckpointInfo();
            render();
        }

        function updateHearts() {
            const hearts = document.querySelectorAll('.heart');
            hearts.forEach((heart, i) => {
                if (i < g.lives) {
                    heart.classList.remove('lost');
                } else {
                    heart.classList.add('lost');
                }
            });
        }

        function updateCheckpointInfo() {
            const cpInfo = document.getElementById('checkpoint-info');
            const gridCounter = document.getElementById('grid-counter');
            const checkpoints = [
                { num: 1, target: 5, label: '0/5 Grids' },
                { num: 2, target: 10, label: '5/10 Grids' },
                { num: 3, target: 15, label: '10/15 Grids' },
                { num: 4, target: 20, label: '15/20 Grids' },
                { num: 5, target: 25, label: '20/25 Grids' }
            ];
            const current = checkpoints[g.checkpoint - 1];
            const nextTarget = current.target;
            cpInfo.innerHTML = `Checkpoint ${current.num} <span class="cp-label">[${g.gridsSolved}/${nextTarget} Grids]</span>`;
            gridCounter.innerText = `Grids Solved: ${g.gridsSolved}`;
        }

        function getCheckpoint(gridsSolved) {
            if (gridsSolved < 5) return { cp: 1, startLevel: 1, startGrids: 0 };
            if (gridsSolved < 10) return { cp: 2, startLevel: g.checkpointLevel, startGrids: 5 };
            if (gridsSolved < 15) return { cp: 3, startLevel: g.checkpointLevel, startGrids: 10 };
            if (gridsSolved < 20) return { cp: 4, startLevel: g.checkpointLevel, startGrids: 15 };
            return { cp: 5, startLevel: g.checkpointLevel, startGrids: 20 };
        }

        function render() {
            // Number appearance based on grids solved
            let n;
            if (g.gridsSolved < 5) {
                n = 3; // Initially 3 numbers
            } else if (g.gridsSolved < 10) {
                n = 4; // After 5 grids, add 4th number
            } else if (g.gridsSolved < 15) {
                n = 5; // After 10 grids, add 5th number
            } else if (g.gridsSolved < 20) {
                n = 6; // After 15 grids, add 6th number
            } else if (g.gridsSolved < 25) {
                n = 7; // After 20 grids, add 7th number
            } else if (g.gridsSolved < 50) {
                n = 8; // After 25 grids, add 8th number
            } else if (g.gridsSolved < 80) {
                n = 9; // After 50 grids, add 9th number
            } else {
                n = 9; // Maximum 9 numbers
            }

            // Level-based timer logic
            let t;
            if (g.cur <= 10) {
                t = 5000; // 5 seconds for levels 1-10
            } else if (g.cur <= 20) {
                t = 4000; // 4 seconds for levels 11-20
            } else if (g.cur <= 30) {
                t = 3000; // 3 seconds for levels 21-30
            } else {
                t = 2000; // 2 seconds for levels 31+
            }
            document.getElementById('lvl-tag').innerText = `Level // ${g.cur.toString().padStart(2, '0')}`;
            const grid = document.getElementById('grid');
            grid.innerHTML = ''; g.data = Array(9).fill(null);
            let pos = [...Array(9).keys()].sort(() => Math.random() - 0.5);
            for (let i = 0; i < n; i++) g.data[pos[i]] = i + 1;

            g.data.forEach((num, i) => {
                const d = document.createElement('div');
                d.className = 'tile'; d.innerText = num || '';
                d.onclick = () => {
                    playTileClick(); // Play click sound + vibrate
                    tap(i);
                };
                grid.appendChild(d);
            });

            const bar = document.getElementById('timer-bar');
            bar.style.transition = 'none'; bar.style.transform = 'scaleX(1)';
            setTimeout(() => { bar.style.transition = `transform ${t}ms linear`; bar.style.transform = 'scaleX(0)'; }, 50);

            g.timer = setTimeout(() => {
                g.state = 'INPUT';
                Array.from(grid.children).forEach(el => { if (el.innerText) el.classList.add('hidden-num'); });
            }, t);
        }

        function tap(i) {
            if (g.state !== 'INPUT') return;
            if (g.data[i] === g.exp) {
                const tile = document.getElementById('grid').children[i];
                tile.classList.remove('hidden-num'); tile.classList.add('correct');
                if (g.exp === g.data.filter(x => x).length) {
                    // Grid complete - increment grids solved
                    g.gridsSolved++;
                    g.cur++;

                    // Update checkpoint if needed
                    const cpData = getCheckpoint(g.gridsSolved);
                    if (cpData.cp > g.checkpoint) {
                        g.checkpoint = cpData.cp;
                        g.checkpointLevel = g.cur; // Save current level as checkpoint
                        g.gridsAtCheckpoint = g.gridsSolved;
                    }

                    // Update the grid counter and checkpoint info
                    updateCheckpointInfo();

                    cfg.streak = 0;
                    clearTimeout(g.timer);
                    start();
                } else g.exp++;
            } else fail();
        }

        function fail() {
            g.state = 'FAIL'; cfg.streak++; clearTimeout(g.timer);

            // Don't lose life here - only on retry
            // updateHearts() will be called when retry is clicked

            // Stop background music on failure
            bgMusic.pause();
            bgMusic.currentTime = 0;

            document.getElementById('game').classList.add('hidden');
            document.getElementById('fail').classList.remove('hidden');
            const msg = document.getElementById('roast-msg');
            const meme = document.getElementById('meme');
            msg.classList.remove('visible');
            meme.style.display = 'none';
            meme.style.opacity = '0';

            // PSYCHOLOGICAL PAUSE: Strict 0.5s delay before any text
            setTimeout(() => {
                // Select roast pool based on language
                let roastPool = cfg.lang === 'hi' ? ROASTS.hinglish : ROASTS.english;

                // Get unused roasts
                let availableRoasts = roastPool.filter(r => !g.usedRoasts.has(r));
                if (availableRoasts.length === 0) {
                    g.usedRoasts.clear();
                    availableRoasts = roastPool;
                }

                // Select random roast
                let roastText = availableRoasts[Math.floor(Math.random() * availableRoasts.length)];
                g.usedRoasts.add(roastText);

                // Add streak prefix
                if (cfg.streak >= 2) {
                    const prefix = cfg.lang === 'hi' ? 'Phir se? ' : 'Again? ';
                    roastText = prefix + roastText;
                }

                // LEVEL 11+ RULE: Strip all emojis for cold seriousness
                if (g.cur >= 11) {
                    roastText = roastText.replace(/[\u{1F600}-\u{1F64F}]|[\u{1F300}-\u{1F5FF}]|[\u{1F680}-\u{1F6FF}]|[\u{1F1E0}-\u{1F1FF}]|[\u{2600}-\u{26FF}]|[\u{2700}-\u{27BF}]|[\u{1F900}-\u{1F9FF}]|[\u{1F018}-\u{1F270}]|[\u{238C}-\u{2454}]|[\u{20D0}-\u{20FF}]/gu, '');
                }

                // Display roast text
                msg.innerText = roastText;
                msg.classList.add('visible');

                // Update stats with lives info
                const livesText = g.lives > 0 ? `Lives: ${g.lives}/5` : 'GAME OVER';
                document.getElementById('stats').innerText = `Best: ${Math.max(g.cur, localStorage.getItem('recall-best') || 0)} | ${livesText}`;

                // Show meme after delay (on any wrong attempt)
                setTimeout(() => {
                    // Get random meme
                    let availableMemes = ROASTS.memes.filter(m => !g.usedMemes.has(m));
                    if (availableMemes.length === 0) {
                        g.usedMemes.clear();
                        availableMemes = ROASTS.memes;
                    }

                    if (availableMemes.length > 0) {
                        const selectedMeme = availableMemes[Math.floor(Math.random() * availableMemes.length)];
                        g.usedMemes.add(selectedMeme);

                        // Add meme intro message
                        const memeIntro = cfg.lang === 'hi'
                            ? '\n\nRuko ek perfect meme tumhare liye mere taraf se! ðŸ˜'
                            : '\n\nWait I\'ve got a perfect meme for you! ðŸ˜';

                        msg.innerText += memeIntro;

                        // Show meme
                        setTimeout(() => {
                            meme.style.backgroundImage = `url(${selectedMeme})`;
                            meme.style.display = 'block';

                            setTimeout(() => {
                                meme.style.opacity = '1';
                                meme.style.filter = 'grayscale(0)';
                            }, 100);
                        }, 1000); // 1 second delay before showing meme
                    }
                }, 500); // 0.5s delay before meme intro
            }, 500); // 0.5s delay for initial roast
        }

        // Create a separate retry function for the Re-Try button
        function retryGame() {
            // Lose a life on retry
            g.lives--;
            updateHearts();

            // If out of lives, restart from checkpoint level
            if (g.lives <= 0) {
                g.cur = g.checkpointLevel;
                g.lives = 5;
                g.gridsSolved = g.gridsAtCheckpoint;
                // Keep current checkpoint
            } else {
                // Restart from current level with remaining lives
                // DON'T reset gridsSolved - keep progress!
                // Player keeps trying the same level until success
            }
            start();
        }

        // Override the retry button to handle checkpoint restart
        const originalStart = start;
        window.start = function () {
            // This function should now only call the original start logic
            // The retry logic (life loss, checkpoint reset) is moved to retryGame()
            originalStart();
        };
    </script>
</body>

</html>